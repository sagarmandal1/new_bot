from telegram import Update, InlineKeyboardMarkup, InlineKeyboardButton
from telegram.ext import ContextTypes
from datetime import datetime, timedelta
from collections import Counter
from bot.services.routine_service import RoutineService
from bot.services.user_service import UserService
from bot.utils.helpers import get_text, get_today_date, get_week_dates, get_month_dates, calculate_success_rate

class ReportHandlers:
    """Handlers for report generation and statistics"""
    
    def __init__(self, routine_service: RoutineService, user_service: UserService):
        self.routine_service = routine_service
        self.user_service = user_service
    
    async def reports_menu(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        """Show reports menu"""
        user_id = update.effective_user.id
        
        if not self.user_service.is_user_registered(user_id):
            user_lang = "bengali"
            text = get_text(user_lang)
            await update.message.reply_text(text["registration_needed"])
            return
        
        user_lang = self.user_service.get_user_language(user_id)
        text = get_text(user_lang)
        
        keyboard = [
            [InlineKeyboardButton(text["daily_report"], callback_data="report_daily")],
            [InlineKeyboardButton(text["weekly_report"], callback_data="report_weekly")],
            [InlineKeyboardButton(text["monthly_report"], callback_data="report_monthly")],
            [InlineKeyboardButton("üìà ‡¶∏‡¶∞‡ßç‡¶¨‡¶ï‡¶æ‡¶≤‡ßá‡¶∞ ‡¶™‡¶∞‡¶ø‡¶∏‡¶Ç‡¶ñ‡ßç‡¶Ø‡¶æ‡¶®", callback_data="report_all_time")]
        ]
        
        await update.message.reply_text(
            "üìä *‡¶∞‡¶ø‡¶™‡ßã‡¶∞‡ßç‡¶ü ‡¶Æ‡ßá‡¶®‡ßÅ*\n\n‡¶ï‡ßã‡¶® ‡¶ß‡¶∞‡¶®‡ßá‡¶∞ ‡¶∞‡¶ø‡¶™‡ßã‡¶∞‡ßç‡¶ü ‡¶¶‡ßá‡¶ñ‡¶§‡ßá ‡¶ö‡¶æ‡¶®?",
            parse_mode='Markdown',
            reply_markup=InlineKeyboardMarkup(keyboard)
        )
    
    async def report_callback(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        """Handle report callback buttons"""
        query = update.callback_query
        user_id = query.from_user.id
        data = query.data
        
        user_lang = self.user_service.get_user_language(user_id)
        text = get_text(user_lang)
        
        if data == "report_daily":
            await self._generate_daily_report(query, user_id, text)
        elif data == "report_weekly":
            await self._generate_weekly_report(query, user_id, text)
        elif data == "report_monthly":
            await self._generate_monthly_report(query, user_id, text)
        elif data == "report_all_time":
            await self._generate_all_time_report(query, user_id, text)
    
    async def _generate_daily_report(self, query, user_id: int, text: dict):
        """Generate daily report"""
        today = get_today_date()
        today_routines = self.routine_service.get_today_routines(user_id)
        reports = self.routine_service.db.get_user_reports(user_id)
        
        # Get completions for today
        today_completions = [r for r in reports if r['date'] == today]
        completed_count = len(today_completions)
        total_count = len(today_routines)
        
        if total_count == 0:
            report_text = "üìÖ *‡¶Ü‡¶ú‡¶ï‡ßá‡¶∞ ‡¶∞‡¶ø‡¶™‡ßã‡¶∞‡ßç‡¶ü*\n\n‡¶Ü‡¶ú‡¶ï‡ßá‡¶∞ ‡¶ú‡¶®‡ßç‡¶Ø ‡¶ï‡ßã‡¶® ‡¶∞‡ßÅ‡¶ü‡¶ø‡¶® ‡¶®‡ßá‡¶á‡•§"
        else:
            success_rate = calculate_success_rate(completed_count, total_count)
            
            report_text = f"""
üìÖ *‡¶Ü‡¶ú‡¶ï‡ßá‡¶∞ ‡¶∞‡¶ø‡¶™‡ßã‡¶∞‡ßç‡¶ü* ({today})

‚úÖ ‡¶∏‡¶Æ‡ßç‡¶™‡¶®‡ßç‡¶®: {completed_count}/{total_count}
üìä ‡¶∏‡¶´‡¶≤‡¶§‡¶æ‡¶∞ ‡¶π‡¶æ‡¶∞: {success_rate}%

{'üéâ ‡¶ö‡¶Æ‡ßé‡¶ï‡¶æ‡¶∞!' if success_rate >= 80 else 'üí™ ‡¶Ü‡¶∞‡ßã ‡¶≠‡¶æ‡¶≤‡ßã ‡¶ï‡¶∞‡¶æ‡¶∞ ‡¶ö‡ßá‡¶∑‡ßç‡¶ü‡¶æ ‡¶ï‡¶∞‡ßÅ‡¶®!' if success_rate >= 50 else '‚ö° ‡¶Ü‡¶∞‡ßã ‡¶Æ‡¶®‡ßã‡¶Ø‡ßã‡¶ó ‡¶¶‡¶ø‡¶®!'}
            """
            
            # Add details of today's routines
            if today_routines:
                report_text += "\nüìã *‡¶Ü‡¶ú‡¶ï‡ßá‡¶∞ ‡¶∞‡ßÅ‡¶ü‡¶ø‡¶®‡¶∏‡¶Æ‡ßÇ‡¶π:*\n"
                for routine_id, routine in today_routines.items():
                    completed_today = any(r['routine_id'] == routine_id for r in today_completions)
                    status = "‚úÖ" if completed_today else "‚è∏Ô∏è"
                    report_text += f"{status} {routine['name']} ({routine['time']})\n"
        
        await query.edit_message_text(report_text, parse_mode='Markdown')
    
    async def _generate_weekly_report(self, query, user_id: int, text: dict):
        """Generate weekly report"""
        week_start, week_end = get_week_dates()
        reports = self.routine_service.db.get_user_reports(user_id)
        
        # Filter reports for this week
        week_reports = []
        for report in reports:
            if week_start <= report['date'] <= week_end:
                week_reports.append(report)
        
        # Get all routines to calculate total possible completions
        user_routines = self.routine_service.get_user_routines(user_id)
        daily_routines = [r for r in user_routines.values() if r.get('frequency') in ['daily', '‡¶™‡ßç‡¶∞‡¶§‡¶ø‡¶¶‡¶ø‡¶®']]
        
        # Calculate statistics
        completed_count = len(week_reports)
        days_in_week = 7
        total_possible = len(daily_routines) * days_in_week
        
        # Count completions by day
        daily_counts = Counter(report['date'] for report in week_reports)
        
        success_rate = calculate_success_rate(completed_count, total_possible) if total_possible > 0 else 0
        
        report_text = f"""
üìà *‡¶∏‡¶æ‡¶™‡ßç‡¶§‡¶æ‡¶π‡¶ø‡¶ï ‡¶∞‡¶ø‡¶™‡ßã‡¶∞‡ßç‡¶ü*
({week_start} ‡¶•‡ßá‡¶ï‡ßá {week_end})

‚úÖ ‡¶Æ‡ßã‡¶ü ‡¶∏‡¶Æ‡ßç‡¶™‡¶®‡ßç‡¶®: {completed_count}
üìä ‡¶∏‡¶´‡¶≤‡¶§‡¶æ‡¶∞ ‡¶π‡¶æ‡¶∞: {success_rate}%
üìÖ ‡¶∏‡¶ï‡ßç‡¶∞‡¶ø‡¶Ø‡¶º ‡¶¶‡¶ø‡¶®: {len(daily_counts)}/7

üèÜ {'‡¶ö‡¶Æ‡ßé‡¶ï‡¶æ‡¶∞ ‡¶∏‡¶™‡ßç‡¶§‡¶æ‡¶π!' if success_rate >= 70 else 'üëç ‡¶≠‡¶æ‡¶≤‡ßã!' if success_rate >= 50 else 'üí™ ‡¶™‡¶∞‡ßá‡¶∞ ‡¶∏‡¶™‡ßç‡¶§‡¶æ‡¶π ‡¶Ü‡¶∞‡ßã ‡¶≠‡¶æ‡¶≤‡ßã ‡¶ï‡¶∞‡ßÅ‡¶®!'}
        """
        
        # Add daily breakdown
        if daily_counts:
            report_text += "\nüìä *‡¶¶‡ßà‡¶®‡¶ø‡¶ï ‡¶¨‡ßç‡¶∞‡ßá‡¶ï‡¶°‡¶æ‡¶â‡¶®:*\n"
            for date, count in sorted(daily_counts.items()):
                day_name = datetime.strptime(date, '%Y-%m-%d').strftime('%A')
                report_text += f"{date} ({day_name}): {count} ‡¶ü‡¶ø\n"
        
        await query.edit_message_text(report_text, parse_mode='Markdown')
    
    async def _generate_monthly_report(self, query, user_id: int, text: dict):
        """Generate monthly report"""
        month_start, month_end = get_month_dates()
        reports = self.routine_service.db.get_user_reports(user_id)
        
        # Filter reports for this month
        month_reports = []
        for report in reports:
            if month_start <= report['date'] <= month_end:
                month_reports.append(report)
        
        # Get routine statistics
        user_routines = self.routine_service.get_user_routines(user_id)
        completed_count = len(month_reports)
        
        # Calculate days in month and active days
        start_date = datetime.strptime(month_start, '%Y-%m-%d')
        end_date = datetime.strptime(month_end, '%Y-%m-%d')
        days_in_month = (end_date - start_date).days + 1
        
        daily_counts = Counter(report['date'] for report in month_reports)
        active_days = len(daily_counts)
        
        # Calculate average per day
        avg_per_day = completed_count / days_in_month if days_in_month > 0 else 0
        
        report_text = f"""
üìâ *‡¶Æ‡¶æ‡¶∏‡¶ø‡¶ï ‡¶∞‡¶ø‡¶™‡ßã‡¶∞‡ßç‡¶ü*
({start_date.strftime('%B %Y')})

‚úÖ ‡¶Æ‡ßã‡¶ü ‡¶∏‡¶Æ‡ßç‡¶™‡¶®‡ßç‡¶®: {completed_count}
üìÖ ‡¶∏‡¶ï‡ßç‡¶∞‡¶ø‡¶Ø‡¶º ‡¶¶‡¶ø‡¶®: {active_days}/{days_in_month}
üìä ‡¶¶‡ßà‡¶®‡¶ø‡¶ï ‡¶ó‡¶°‡¶º: {avg_per_day:.1f}
üéØ ‡¶∏‡¶¨‡¶ö‡ßá‡¶Ø‡¶º‡ßá ‡¶¨‡ßá‡¶∂‡¶ø: {max(daily_counts.values()) if daily_counts else 0} ‡¶ü‡¶ø (‡¶è‡¶ï ‡¶¶‡¶ø‡¶®‡ßá)

{'üèÜ ‡¶Ö‡¶∏‡¶æ‡¶ß‡¶æ‡¶∞‡¶£ ‡¶Æ‡¶æ‡¶∏!' if avg_per_day >= 3 else 'üëç ‡¶≠‡¶æ‡¶≤‡ßã!' if avg_per_day >= 2 else 'üí™ ‡¶Ü‡¶∞‡ßã ‡¶â‡¶®‡ßç‡¶®‡¶§‡¶ø ‡¶∏‡¶Æ‡ßç‡¶≠‡¶¨!'}
        """
        
        # Add weekly breakdown
        if daily_counts:
            # Group by weeks
            week_stats = {}
            for date_str, count in daily_counts.items():
                date_obj = datetime.strptime(date_str, '%Y-%m-%d')
                week_num = date_obj.isocalendar()[1]
                week_stats[week_num] = week_stats.get(week_num, 0) + count
            
            if len(week_stats) > 1:
                report_text += "\nüìà *‡¶∏‡¶æ‡¶™‡ßç‡¶§‡¶æ‡¶π‡¶ø‡¶ï ‡¶¨‡ßç‡¶∞‡ßá‡¶ï‡¶°‡¶æ‡¶â‡¶®:*\n"
                for week, count in sorted(week_stats.items()):
                    report_text += f"‡¶∏‡¶™‡ßç‡¶§‡¶æ‡¶π {week}: {count} ‡¶ü‡¶ø\n"
        
        await query.edit_message_text(report_text, parse_mode='Markdown')
    
    async def _generate_all_time_report(self, query, user_id: int, text: dict):
        """Generate all-time statistics report"""
        reports = self.routine_service.db.get_user_reports(user_id)
        user_routines = self.routine_service.get_user_routines(user_id)
        user_data = self.user_service.get_user(user_id)
        
        if not reports:
            await query.edit_message_text("üìä *‡¶∏‡¶∞‡ßç‡¶¨‡¶ï‡¶æ‡¶≤‡ßá‡¶∞ ‡¶™‡¶∞‡¶ø‡¶∏‡¶Ç‡¶ñ‡ßç‡¶Ø‡¶æ‡¶®*\n\n‡¶è‡¶ñ‡¶®‡¶ì ‡¶ï‡ßã‡¶® ‡¶∞‡ßÅ‡¶ü‡¶ø‡¶® ‡¶∏‡¶Æ‡ßç‡¶™‡¶®‡ßç‡¶® ‡¶ï‡¶∞‡ßá‡¶®‡¶®‡¶ø‡•§")
            return
        
        total_completions = len(reports)
        total_routines = len(user_routines)
        
        # Calculate date range
        dates = [report['date'] for report in reports]
        first_completion = min(dates)
        last_completion = max(dates)
        
        # Most completed routines
        routine_counts = Counter(report['routine_id'] for report in reports)
        most_completed_id = routine_counts.most_common(1)[0][0] if routine_counts else None
        most_completed_name = "N/A"
        
        if most_completed_id:
            for routine_id, routine in user_routines.items():
                if routine_id == most_completed_id:
                    most_completed_name = routine['name']
                    break
        
        # Calculate streak and other stats
        daily_counts = Counter(report['date'] for report in reports)
        active_days = len(daily_counts)
        
        # Join date
        join_date = user_data.get('created_at', '').split('T')[0] if user_data else ''
        
        report_text = f"""
üìä *‡¶∏‡¶∞‡ßç‡¶¨‡¶ï‡¶æ‡¶≤‡ßá‡¶∞ ‡¶™‡¶∞‡¶ø‡¶∏‡¶Ç‡¶ñ‡ßç‡¶Ø‡¶æ‡¶®*

üéØ ‡¶Æ‡ßã‡¶ü ‡¶∞‡ßÅ‡¶ü‡¶ø‡¶®: {total_routines}
‚úÖ ‡¶Æ‡ßã‡¶ü ‡¶∏‡¶Æ‡ßç‡¶™‡¶®‡ßç‡¶®: {total_completions}
üìÖ ‡¶∏‡¶ï‡ßç‡¶∞‡¶ø‡¶Ø‡¶º ‡¶¶‡¶ø‡¶®: {active_days}
üìà ‡¶¶‡ßà‡¶®‡¶ø‡¶ï ‡¶ó‡¶°‡¶º: {total_completions/active_days:.1f}

üèÜ ‡¶∏‡¶¨‡¶ö‡ßá‡¶Ø‡¶º‡ßá ‡¶¨‡ßá‡¶∂‡¶ø ‡¶∏‡¶Æ‡ßç‡¶™‡¶®‡ßç‡¶®: 
   {most_completed_name} ({routine_counts[most_completed_id] if most_completed_id else 0} ‡¶¨‡¶æ‡¶∞)

üìÜ ‡¶™‡ßç‡¶∞‡¶•‡¶Æ ‡¶∏‡¶Æ‡ßç‡¶™‡¶®‡ßç‡¶®: {first_completion}
üìÜ ‡¶∏‡¶∞‡ßç‡¶¨‡¶∂‡ßá‡¶∑ ‡¶∏‡¶Æ‡ßç‡¶™‡¶®‡ßç‡¶®: {last_completion}
üóìÔ∏è ‡¶Ø‡ßã‡¶ó‡¶¶‡¶æ‡¶®: {join_date}

{'üèÜ ‡¶¶‡ßÅ‡¶∞‡ßç‡¶¶‡¶æ‡¶®‡ßç‡¶§! ‡¶ö‡¶æ‡¶≤‡¶ø‡¶Ø‡¶º‡ßá ‡¶Ø‡¶æ‡¶®!' if total_completions >= 50 else 'üëç ‡¶≠‡¶æ‡¶≤‡ßã ‡¶Ö‡¶ó‡ßç‡¶∞‡¶ó‡¶§‡¶ø!' if total_completions >= 20 else 'üí™ ‡¶Ü‡¶∞‡ßã ‡¶®‡¶ø‡¶Ø‡¶º‡¶Æ‡¶ø‡¶§ ‡¶π‡¶®!'}
        """
        
        await query.edit_message_text(report_text, parse_mode='Markdown')